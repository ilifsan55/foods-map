{"ast":null,"code":"var _jsxFileName = \"/Users/kokiyamamoto/Desktop/projects/FoodsMap/src/components/gmap.jsx\",\n    _s = $RefreshSig$();\n\nimport React, { useEffect } from 'react';\nimport { resultListSlice } from '../redux/resultListSlice';\nimport { appSlice } from '../redux/appSlice';\nimport { useSelector, useDispatch } from 'react-redux';\nimport './gmap.css';\nimport axios from 'axios';\nimport { initMap, initService } from './gmapapi';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nlet map, service;\nlet shouldMapInitialize = true;\nconst radius = 1000;\n\nasync function asyncCall(req, loc) {\n  const result = await searchPlaces(req, loc);\n  return result;\n}\n\nfunction GMap(props) {\n  _s();\n\n  let dispatch = useDispatch();\n  const searchRequest = useSelector(state => state.app.searchRequest);\n  const GmapMemo = /*#__PURE__*/React.memo(props => {\n    return /*#__PURE__*/_jsxDEV(\"h1\", {\n      children: [\"Hello \", props.name]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 28,\n      columnNumber: 16\n    }, this);\n  });\n\n  if (searchRequest.isDone == false) {\n    dispatch(appSlice.actions.setRequestDone());\n    let results = searchPlaces(searchRequest, props.userLoc);\n    console.dispatch(resultListSlice.actions.setSearchResult(asyncCall));\n  }\n\n  useEffect(() => {\n    if (shouldMapInitialize) {\n      map = initMap(document.getElementById('map'), props.userLoc, props.radius);\n      service = initService(map);\n      shouldMapInitialize = false;\n    }\n  });\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {},\n      id: \"map\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 49,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 48,\n    columnNumber: 9\n  }, this);\n}\n\n_s(GMap, \"sc9UXUIjK8lcBhZr4AuuKVadzTY=\", false, function () {\n  return [useDispatch, useSelector];\n});\n\n_c = GMap;\n\nfunction searchPlaces(req, userLoc) {\n  let apiKeyHotPepper = '1ff50644037f0f38';\n  const apiURL = 'http://webservice.recruit.co.jp/hotpepper/gourmet/v1/?key=[APIキー]&lat=34.67&lng=135.52&count=100&range=5&order=4'; //a request object for the initial search.\n\n  let request = {\n    location: userLoc,\n    radius: req.radius,\n    keyword: req.keyword,\n    type: 'restaurant' //only one type can be specified at once!! should i consider adding the other types like cafe and etcetc?? this can be achived by simply running the another search and add up results\n\n  };\n  getPlace(request).then(response => {\n    let res = resultsParser(response); //places found! put them into parser to parse them for easier prossesing.\n\n    return res;\n  }).catch(status => {\n    let res = resultsParser(0); //error in searching.\n\n    return res;\n  });\n}\n\nfunction CreateMarker(place, index) {\n  let marker = new window.google.maps.Marker({\n    map: map,\n    label: String(index),\n    position: place.geometry.location\n  });\n}\n\n_c2 = CreateMarker;\n\nfunction resultsParser(results) {\n  let parsedResults = [];\n\n  if (results == 0 || results.length <= 0) {\n    let result_temp = {};\n    result_temp.name = '何も見つかりませんでした。';\n    result_temp.vicinity = '';\n    result_temp.rating = '';\n    parsedResults.push(result_temp);\n    return parsedResults;\n  }\n\n  for (let i = 0; i < results.length; i++) {\n    let result_temp = {};\n    let result = results[i];\n    CreateMarker(result, i + 1);\n    result_temp.name = result.name;\n    result_temp.vicinity = result.vicinity;\n    result_temp.rating = result.rating;\n    result_temp.lat = result.geometry.location.lat();\n    result_temp.lng = result.geometry.location.lng();\n    parsedResults.push(result_temp);\n  }\n\n  return parsedResults;\n}\n\nfunction getPlace(request) {\n  return new Promise((resolve, reject) => {\n    service.nearbySearch(request, (results, status) => {\n      if (status === 'OK') {\n        resolve(results);\n      } else {\n        reject(status);\n      }\n    });\n  });\n}\n\n;\nexport default GMap;\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"GMap\");\n$RefreshReg$(_c2, \"CreateMarker\");","map":{"version":3,"names":["React","useEffect","resultListSlice","appSlice","useSelector","useDispatch","axios","initMap","initService","map","service","shouldMapInitialize","radius","asyncCall","req","loc","result","searchPlaces","GMap","props","dispatch","searchRequest","state","app","GmapMemo","memo","name","isDone","actions","setRequestDone","results","userLoc","console","setSearchResult","document","getElementById","apiKeyHotPepper","apiURL","request","location","keyword","type","getPlace","then","response","res","resultsParser","catch","status","CreateMarker","place","index","marker","window","google","maps","Marker","label","String","position","geometry","parsedResults","length","result_temp","vicinity","rating","push","i","lat","lng","Promise","resolve","reject","nearbySearch"],"sources":["/Users/kokiyamamoto/Desktop/projects/FoodsMap/src/components/gmap.jsx"],"sourcesContent":["import React, { useEffect } from 'react';\nimport { resultListSlice } from '../redux/resultListSlice';\nimport { appSlice } from '../redux/appSlice';\nimport { useSelector, useDispatch } from 'react-redux';\nimport './gmap.css';\nimport axios from 'axios';\nimport {initMap, initService} from './gmapapi'\n\n\nlet map, service;\nlet shouldMapInitialize = true;\nconst radius = 1000;\n\nasync function asyncCall(req,loc) {\n    const result = await searchPlaces(req,loc);\n    return result;\n    \n}\n  \n\nfunction GMap(props) {\n\n    let dispatch = useDispatch();\n\n    const searchRequest = useSelector(state => state.app.searchRequest);\n\n    const GmapMemo = React.memo(props => {\n        return <h1>Hello {props.name}</h1>;\n    });\n\n    if (searchRequest.isDone == false) {\n        \n        dispatch(appSlice.actions.setRequestDone());\n        let results = searchPlaces(searchRequest, props.userLoc);\n        console.\n        dispatch(resultListSlice.actions.setSearchResult(asyncCall));\n        \n    }\n\n    useEffect(() => {\n        if (shouldMapInitialize) {\n            map = initMap(document.getElementById('map'), props.userLoc, props.radius);\n            service = initService(map);\n            shouldMapInitialize = false;\n        }\n    })\n    return (\n        <div>\n            <div style={{}} id='map'></div>\n        </div>\n    )\n}\n\nfunction searchPlaces(req, userLoc) {\n\n    let apiKeyHotPepper = '1ff50644037f0f38';\n    const apiURL = 'http://webservice.recruit.co.jp/hotpepper/gourmet/v1/?key=[APIキー]&lat=34.67&lng=135.52&count=100&range=5&order=4';\n\n    //a request object for the initial search.\n    let request = {\n        location: userLoc,\n        radius: req.radius,\n        keyword: req.keyword,\n        type: 'restaurant',//only one type can be specified at once!! should i consider adding the other types like cafe and etcetc?? this can be achived by simply running the another search and add up results\n\n    };\n\n    getPlace(request).then((response) => {\n\n        let res = resultsParser(response);//places found! put them into parser to parse them for easier prossesing.\n        return res;\n\n    }).catch((status) => {\n\n        let res = resultsParser(0); //error in searching.\n        return res;\n\n    });\n\n}\n\n\n\nfunction CreateMarker(place, index) {\n\n    let marker = new window.google.maps.Marker({\n        map: map,\n        label: String(index),\n        position: place.geometry.location\n    });\n\n}\n\n\nfunction resultsParser(results) {\n\n    let parsedResults = [];\n    if (results == 0 || results.length <= 0) {\n\n        let result_temp = {};\n        result_temp.name = '何も見つかりませんでした。';\n        result_temp.vicinity = '';\n        result_temp.rating = '';\n        parsedResults.push(result_temp);\n        return parsedResults;\n\n    }\n    for (let i = 0; i < results.length; i++) {\n\n        let result_temp = {};\n        let result = results[i];\n        CreateMarker(result, i + 1);\n\n        result_temp.name = result.name;\n        result_temp.vicinity = result.vicinity;\n        result_temp.rating = result.rating;\n        result_temp.lat = result.geometry.location.lat();\n        result_temp.lng = result.geometry.location.lng();\n        parsedResults.push(result_temp);\n    }\n\n    return parsedResults;\n\n}\n\nfunction getPlace(request) {\n    return new Promise((resolve, reject) => {\n        service.nearbySearch(request, (results, status) => {\n            if (status === 'OK') {\n                resolve(results);\n            } else {\n                reject(status);\n            }\n        });\n    });\n};\n\n\nexport default GMap;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}